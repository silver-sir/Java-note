## 2 线程的创建

方式：Thread、Runable、Callable（可携带参数）、线程池（调用第三方插件时推荐）



#### 线程的生命周期

1. 新建（new对象）
2. 就绪（通过线程对象的start()方法启动线程时对应的状态，此时并不一定马上能进入运行状态，线程的运行有操作系统的调度程序控制）
3. 运行（得到了cpu的执行权，线程正在执行需要执行的代码）
4. 阻塞（BLOCKED称为阻塞状态。线程被挂起，等待一个‘锁’）
5. 等待（有限期等待、无限期等待）
6. 结束（线程结束，释放资源）                                                                                                                                                                   

​    

## 3 线程的中断

概念：每个线程有一个布尔型的标志位，代表线程是否中断，只需要设置被中断的线程标志位为true，被中断的线程在合适的时候中断。

* Java中线程中断是一种协作机制
* 通过中断并不能直接终止线程的运行
* 需要被中断的线程自己处理中断

**注意：线程中断不是立刻停止的**

#### 相关方法

public static boolean interrupted()

* 测试当前线程是否已经中断，会清除中断状态
* 连续两次调用，第二次返回false

public boolean isInterrupted()

* 判断是否已经中断，不会清除中断状态

public void interrupt()

* 将调用该方法的对象所表示的线程标记一个停止标记
* 唯一能将中断状态设为true的方法

## 4 安全终止线程

1. 设置退出标识（public volatile boolean exit = false）

2. 中断的方式终止线程

   ​	方法：Thread.join();可以接受中断，用处让出线程

   ​				Thread.sleep();

   ​				ServerSocket.accept();

   ​				当线程阻塞时，退出标志不生效（无法检查循环标志）

   ​				Thread的interrupt()方法终止线程（设置线程中断）

3. 废弃的终止方式

   Thread.stop();    

   Thread.suspend();(使线程暂停，不会释放类似锁这样的资源) Thread.resume();(使线程恢复，必须与suspend成对出现，容易出现死锁，因为suspend方法不会释放锁)

   Runtime.runFinalizersOnExit();（方法本身不安全，可能导致终结器在活跃对象上被调用）

## 5 线程的优先级　守护线程

#### 线程的优先级

1. 在Java中，线程优先级的范围1-10，默认为5
2. 高优先级会优先于低优先级执行（尽量保证）



特性： 

继承特性：线程A启动线程B，具有相同的优先级

规则性：CPU尽量将资源分配给高优先级的线程，但不能保证先执行完

随机性：不能保证执行先后，线程运行具有随机性



两种线程

1. 用户线程——执行用户级的任务
2. 守护线程——后台线程，一般用于执行后台任务
3. isDaemon()方法区分，返回false是“用户线程”，否则是守护线程
4. Java虚拟机在“用户线程”都结束后会退出。

#### 守护线程

1. 指在程序运行的时候在后台提供一种通用服务的线程
2. 不是不可或缺的（eg.垃圾回收线程）
3. 当所有用户线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程

